<!-- 
let index = 1;
const convertTreeNode = object => Array.isArray(object)
  ? object.map(element => ({
    id: index++,
    name: element,
    children: typeof(object[element]) === "object"
      ? convertTreeNode(object[element])
      : []
  }))
  : Object.keys(object).map(element => ({
    id: index++,
    name: element,
    children: typeof(object[element]) === "object"
      ? convertTreeNode(object[element])
      : []
  }));
axios.defaults.headers.post['Authorization'] = 'Bearer ' + context.getters.TOKEN;
axios.post('/portal/api/v1.0/permissions')
  .then(response => {
    const permissions = convertTreeNode({ ...response?.data?.permissions });
    context.commit('SET_PERMISSIONS', permissions);
  })
  .catch(error => {
    context.dispatch('LOGOUT');
    context.dispatch('SET_ERROR_ALERT', error?.response?.data?.errors?.map(error => error.message) || [error] || ["Unknown server error"]);
  }); -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://img.icons8.com/clouds/512/globe.png">
  <!-- <script src="//d3js.org/d3.v3.min.js"></script> -->
  <script src="https://d3js.org/d3.v7.min.js"></script>


  <script type="module">
    import {treemap} from "https://cdn.skypack.dev/d3-hierarchy@3";
    // import {hierarchy} from "https://cdn.skypack.dev/pin/d3-hierarchy@v3.1.2-wx7sW10pU4OkfBLgCDCU/mode=imports/optimized/d3-hierarchy.js";
    
    // export * from '/-/d3-hierarchy@v3.1.2-wx7sW10pU4OkfBLgCDCU/dist=es2019,mode=imports/optimized/d3-hierarchy.js';
    // export {default} from '/-/d3-hierarchy@v3.1.2-wx7sW10pU4OkfBLgCDCU/dist=es2019,mode=imports/optimized/d3-hierarchy.js';
    const tree = treemap();
  </script>


  <script>
  // Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/tree
function Tree(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
  path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
  id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
  parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
  children, // if hierarchical data, given a d in data, returns its children
  tree = d3.tree, // layout algorithm (typically d3.tree or d3.cluster)
  sort, // how to sort nodes prior to layout (e.g., (a, b) => d3.descending(a.height, b.height))
  label, // given a node d, returns the display name
  title, // given a node d, returns its hover text
  link, // given a node d, its link (if any)
  linkTarget = "_blank", // the target attribute for links (if any)
  width = 640, // outer width, in pixels
  height, // outer height, in pixels
  r = 3, // radius of nodes
  padding = 1, // horizontal padding for first and last column
  fill = "#999", // fill for nodes
  fillOpacity, // fill opacity for nodes
  stroke = "#555", // stroke for links
  strokeWidth = 1.5, // stroke width for links
  strokeOpacity = 0.4, // stroke opacity for links
  strokeLinejoin, // stroke line join for links
  strokeLinecap, // stroke line cap for links
  halo = "#fff", // color of label halo 
  haloWidth = 3, // padding around the labels
  curve = d3.curveBumpX, // curve for the link
} = {}) {

  // If id and parentId options are specified, or the path option, use d3.stratify
  // to convert tabular data to a hierarchy; otherwise we assume that the data is
  // specified as an object {children} with nested objects (a.k.a. the “flare.json”
  // format), and use d3.hierarchy.
  const root = path != null ? d3.stratify().path(path)(data)
      : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)
      : d3.hierarchy(data, children);

  // Sort the nodes.
  if (sort != null) root.sort(sort);

  // Compute labels and titles.
  const descendants = root.descendants();
  const L = label == null ? null : descendants.map(d => label(d.data, d));

  // Compute the layout.
  const dx = 10;
  const dy = width / (root.height + padding);
  tree().nodeSize([dx, dy])(root);

  // Center the tree.
  let x0 = Infinity;
  let x1 = -x0;
  root.each(d => {
    if (d.x > x1) x1 = d.x;
    if (d.x < x0) x0 = d.x;
  });

  // Compute the default height.
  if (height === undefined) height = x1 - x0 + dx * 2;

  // Use the required curve
  if (typeof curve !== "function") throw new Error(`Unsupported curve`);

  const svg = d3.create("svg")
      .attr("viewBox", [-dy * padding / 2, x0 - dx, width, height])
      .attr("width", width)
      .attr("height", height)
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10);

  svg.append("g")
      .attr("fill", "none")
      .attr("stroke", stroke)
      .attr("stroke-opacity", strokeOpacity)
      .attr("stroke-linecap", strokeLinecap)
      .attr("stroke-linejoin", strokeLinejoin)
      .attr("stroke-width", strokeWidth)
    .selectAll("path")
      .data(root.links())
      .join("path")
        .attr("d", d3.link(curve)
            .x(d => d.y)
            .y(d => d.x));

  const node = svg.append("g")
    .selectAll("a")
    .data(root.descendants())
    .join("a")
      .attr("xlink:href", link == null ? null : d => link(d.data, d))
      .attr("target", link == null ? null : linkTarget)
      .attr("transform", d => `translate(${d.y},${d.x})`);

  node.append("circle")
      .attr("fill", d => d.children ? stroke : fill)
      .attr("r", r);

  if (title != null) node.append("title")
      .text(d => title(d.data, d));

  if (L) node.append("text")
      .attr("dy", "0.32em")
      .attr("x", d => d.children ? -6 : 6)
      .attr("text-anchor", d => d.children ? "end" : "start")
      .attr("paint-order", "stroke")
      .attr("stroke", halo)
      .attr("stroke-width", haloWidth)
      .text((d, i) => L[i]);

  return svg.node();
}
  </script>
  <!-- <script src="//d3js.org/d3.v3.min.js"></script> -->
  <!-- <script src="./bs_child/web/tree.js"></script> -->
  <title>Animals sread</title>
  <style>
    body {
      background-color: rgb(42, 42, 42);
    }
  </style>
  
</head>
<body class="container">
	<div style="display: flex; gap: 1rem;justify-content: flex-end;"><input type="number" value="25" id="spreadCountTimes"><button id="update_info">update</button></div>
	<div class="progress-9" style="display:none" id="progress"></div>
	<div id="animals"></div>
</body>
<script>
const baseTree = {
  "name": "Eve",
  "children": [
    {
      "name": "Cain"
    },
    {
      "name": "Seth",
      "children": [
        {
          "name": "Enos"
        },
        {
          "name": "Noam"
        }
      ]
    },
    {
      "name": "Abel"
    },
    {
      "name": "Awan",
      "children": [
        {
          "name": "Enoch"
        }
      ]
    },
    {
      "name": "Azura"
    }
  ]
};

// function children(d) {
//   return d.children;
// }
// function children(d) {
//   return Array.isArray(d) ? d[1] : null;
// }
// root.sum(function(d) { return d.value ? 1 : 0; });
// var treemap = d3.treemap()
//     .size([width, height])
//     .padding(2);
// var nodes = treemap(root
//     .sum(function(d) { return d.value; })
//     .sort(function(a, b) { return b.height - a.height || b.value - a.value; }))
//   .descendants();

// var table = d3.csvParse(`
// name,parent
// Eve,
// Cain,Eve
// Seth,Eve
// Enos,Seth
// Noam,Seth
// Abel,Eve
// Awan,Eve
// Enoch,Awan
// Azura,Eve`);

// var root = d3.stratify()
//     .id(function(d) { return d.name; })
//     .parentId(function(d) { return d.parent; })
//     (table);


// flare = FileAttachment("flare.json").json()

const setView = treeView => animals.append(Tree(treeView, {
  label: d => d.name,
  title: (d, n) => `${n.ancestors().reverse().map(d => d.data.name).join(".")}`, // hover text
  link: (d, n) => `https://github.com/prefuse/Flare/${n.children ? "tree" : "blob"}/master/flare/src/${n.ancestors().reverse().map(d => d.data.name).join("/")}${n.children ? "" : ".as"}`,
  width: screen.width
}));

// setView(baseTree);

</script>
<script>
const getParent = (beast, index) => beast[index] === null && beast[index] !== undefined
	? beast
	: getParent(beast[index], index);
const getNum = num => Math.round(Math.random(num));
const getRandNum = (max = 1, min = 0) => Math.round(Math.random() * (max - min) + min);

const makeStartBeasts = (array, count, time) => {
  for (var i = 0; i < count; i++) {
    var numberOfBeastList = getRandNum();
    array.live[numberOfBeastList].push({
      id: array.live[numberOfBeastList].length,
      // id0: null,
      // id1: null,
			0: null,
			1: null,
      time,
      gen: '000000'.replaceAll('0', () => getRandNum(9, 0)),
    });
  }

  // console.table(Object
  //     .keys(array.live[0][0])
  //     .map(keys => ({
  //       [keys]: array.live[0]
  //         .reduce((summ, el) =>
  //           ((summ < el[keys] && (summ += el[keys])), summ),
  //           ''
  //         )
  //     }))); // log start array

  return array;
};

const spread = (beasts, { maxLiveTime = 2, spreadCountTimes = 10, startCount = 8, maxChildrenCount = 2 }) => {
  var time = new Date().getFullYear();

  makeStartBeasts(beasts, startCount, time);

  for (var spreadCount = 0; spreadCount < spreadCountTimes; spreadCount++) {
    time++;

    if (beasts.live[0].length + beasts.live[1].length === 0) debugger;

    for (var i = 0; i < beasts.live[1].length; i++) {
      if (beasts.live[1][i] === undefined) continue;
      if ((beasts.live[1][i].time + getRandNum(maxLiveTime, 1)) < time ) {
        beasts.death[1].push(beasts.live[1][i]);
        beasts.live[1].splice(i, 1);
        i--;
      }
    }

    var beastsLive_1Copy = [...beasts.live[1]];

    for (var i = 0; i < beasts.live[0].length; i++) {
      if ((beasts.live[0][i].time + getRandNum(maxLiveTime, 1)) < time) {
        beasts.death[0].push(beasts.live[0][i]);
        beasts.live[0].splice(i, 1);
        i--;
        continue;
      }

      var parent = beasts.live[0][i];
      var partnerNum = getRandNum(beastsLive_1Copy.length - 1);
      var partnerBeast = beastsLive_1Copy[partnerNum];
      if (partnerBeast === undefined) continue;
      beastsLive_1Copy.splice(partnerNum, 1);

      // var countOfChildren = getNum(maxChildrenCount) + 1;

      for (var j = 0; j < maxChildrenCount; j++) {
        var numberOfBeastList = getRandNum();
        beasts.live[numberOfBeastList].push({
          id: beasts.live[numberOfBeastList].length,
          // id0: parent.id,
          // id1: partnerBeast.id,
					0: beasts.live[0][i],
          1: beastsLive_1Copy[partnerNum],
          time,
          gen: (numberOfBeastList === 0 ? parent : partnerBeast).gen.substring(0, 3) + (numberOfBeastList === 0 ? partnerBeast : parent).gen.substring(3, 6),
        });
      }
    }
  }

  return beasts;
}

const convertNumbers = num => new Intl.NumberFormat().format(num).replaceAll(',', '_');

const updateBeasts = (__, name, options = {}) => {
  const beasts = spread({ live: [[], []], death: [[], []] }, options = options || {});

  (() => {
		const liveStat = [...JSON.parse(localStorage.getItem('liveStat')) || [], convertNumbers(beasts.live[0].length + beasts.live[1].length)];
		localStorage.setItem('liveStat', JSON.stringify(liveStat));
		const deathStat = [...JSON.parse(localStorage.getItem('deathStat')) || [], convertNumbers(beasts.death[0].length + beasts.death[1].length)];
		localStorage.setItem('deathStat', JSON.stringify(deathStat));
		const l$dStat = [...JSON.parse(localStorage.getItem('l$dStat')) || [], convertNumbers(beasts.live[0].length - beasts.death[0].length + beasts.live[1].length - beasts.death[1].length)];
		localStorage.setItem('l$dStat', JSON.stringify(l$dStat));

    name = `${ name || 'Beasts' } <${ new Date().getMinutes() }:${ new Date().getSeconds() }> | <${ liveStat[liveStat.length - 1] }|${ deathStat[deathStat.length - 1] }|${ l$dStat[l$dStat.length - 1] }>`;
    console.group(name);
    console.table({ ...beasts /*, LiveStat: liveStat, DeathStat: deathStat, 'Live - Death stat': l$dStat */ });
    console.groupEnd(name);
  }) ();

  (() => {
    const divs = [document.createElement('div'), document.createElement('div')];
    // divs[0].style.backgroundColor = 'green';
    // divs[1].style.backgroundColor = 'red';
    divs[0].classList.add('container-a');
    divs[1].classList.add('container-a');

    const addOnPage = (arr, index) => arr.forEach(beast => {
      const div = document.createElement('div');
      div.style.backgroundColor = '#' + beast.gen;
      div.classList.add('beast');
      divs[index].append(div);
    });

    addOnPage(beasts.live[0].splice(0, beasts.live[0].length), 0);
    addOnPage(beasts.live[1].splice(0, beasts.live[1].length), 1);

    animals.innerHTML = '';
    animals.append(...divs);
  }) // run ()

  // (() => {
    // let index = 1;
    // const convertTreeNode = object => // Array.isArray(object)
    //   // ? object.map(element => ({
    //   //   // id: index++,
    //   //   name: 'some ' + index, // object[element] ? object[element].gen : element,
    //   //   children: typeof(object[element]) === "object"
    //   //     ? convertTreeNode(object[element])
    //   //     : []
    //   // }))
    //   object !== null ? Object.keys(object).map(element => ({
    //     id: index++,
    //     name: object[element] ? object[element]?.gen || null : null,
    //     children: typeof(object[element]) === "object"
    //       ? convertTreeNode(object[element])
    //       : []
    //   })) : [];
    // axios.defaults.headers.post['Authorization'] = 'Bearer ' + context.getters.TOKEN;
    // axios.post('/portal/api/v1.0/permissions')
    //   .then(response => {
    //     const permissions = convertTreeNode({ ...response?.data?.permissions });
    //     context.commit('SET_PERMISSIONS', permissions);
    //   })
    //   .catch(error => {
    //     context.dispatch('LOGOUT');
    //     context.dispatch('SET_ERROR_ALERT', error?.response?.data?.errors?.map(error => error.message) || [error] || ["Unknown server error"]);
    //   });
    const beast = beasts.live[0][beasts.live[0].length - 1];

    // let index = 1;
    // const convertTreeNode = object => Object
    //   .keys(object)
    //   .map(key => ({
    //     id: index++,
    //     name: `${key} ${index}`, // object[key] ? object[key]?.gen || null : null,
    //     children: typeof(object[key]) === "object" && object[key] !== null
    //       ? convertTreeNode(object[key])
    //       : []
    //   }));

    const convertTreeNode = object => ({
      name: object.gen,
      children: [0, 1].map(key => object[key] !== null && object[key] !== undefined && convertTreeNode(object[key]))
    });

    console.log(convertTreeNode(beast));
    // const reverseTreeMap = object => object[0] !== null && object[1] !== null 
    //   ? {
    //     reverseTreeMap(object)
    //   } 
    //   : object
    // const beastsLive_0Length = beasts.live[0].length;
    // for (let index = 0; index < beastsLive_0Length; index++) {
    //   beasts.live[0][index];
    //   beastsLive_0Length.push({
    //     name: 
    //   })
    // }
    setView(convertTreeNode(beast));
  // }) ();

	return beasts;
};

const beasts = updateBeasts();
update_info.addEventListener('click', () => {
	animals.innerHTML = ''
	progress.style.display = '';
	setTimeout(() => updateBeasts('', '', { spreadCountTimes: spreadCountTimes.value }), 2000)
	// .then(() => progress.style.display = 'none');
	setTimeout(() => progress.style.display = 'none', 2000)

}, false);

// setInterval(() => updateBeasts(), 1000);

</script>
</html>
