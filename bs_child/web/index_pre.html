<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://img.icons8.com/clouds/512/globe.png">
  <!-- <script src="//d3js.org/d3.v3.min.js"></script> -->
  <script src="./bs_child/web/tree.js"></script>
  <title>Animals sread</title>
  <link rel="stylesheet" href="base.css">

  <script>
    // // Copyright 2021 Observable, Inc.
    // // Released under the ISC license.
    // // https://observablehq.com/@d3/tree
    // function Tree(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
    //   path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
    //   id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
    //   parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
    //   children, // if hierarchical data, given a d in data, returns its children
    //   tree = d3.tree, // layout algorithm (typically d3.tree or d3.cluster)
    //   sort, // how to sort nodes prior to layout (e.g., (a, b) => d3.descending(a.height, b.height))
    //   label, // given a node d, returns the display name
    //   title, // given a node d, returns its hover text
    //   link, // given a node d, its link (if any)
    //   linkTarget = "_blank", // the target attribute for links (if any)
    //   width = 640, // outer width, in pixels
    //   height, // outer height, in pixels
    //   r = 3, // radius of nodes
    //   padding = 1, // horizontal padding for first and last column
    //   fill = "#999", // fill for nodes
    //   fillOpacity, // fill opacity for nodes
    //   stroke = "#555", // stroke for links
    //   strokeWidth = 1.5, // stroke width for links
    //   strokeOpacity = 0.4, // stroke opacity for links
    //   strokeLinejoin, // stroke line join for links
    //   strokeLinecap, // stroke line cap for links
    //   halo = "#fff", // color of label halo
    //   haloWidth = 3, // padding around the labels
    //   curve = d3.curveBumpX, // curve for the link
    // } = {}) {

    //   // If id and parentId options are specified, or the path option, use d3.stratify
    //   // to convert tabular data to a hierarchy; otherwise we assume that the data is
    //   // specified as an object {children} with nested objects (a.k.a. the “flare.json”
    //   // format), and use d3.hierarchy.
    //   const root = path != null ? d3.stratify().path(path)(data)
    //       : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)
    //       : d3.hierarchy(data, children);

    //   // Sort the nodes.
    //   if (sort != null) root.sort(sort);

    //   // Compute labels and titles.
    //   const descendants = root.descendants();
    //   const L = label == null ? null : descendants.map(d => label(d.data, d));

    //   // Compute the layout.
    //   const dx = 10;
    //   const dy = width / (root.height + padding);
    //   tree().nodeSize([dx, dy])(root);

    //   // Center the tree.
    //   let x0 = Infinity;
    //   let x1 = -x0;
    //   root.each(d => {
    //     if (d.x > x1) x1 = d.x;
    //     if (d.x < x0) x0 = d.x;
    //   });

    //   // Compute the default height.
    //   if (height === undefined) height = x1 - x0 + dx * 2;

    //   // Use the required curve
    //   if (typeof curve !== "function") throw new Error(`Unsupported curve`);

    //   const svg = d3.create("svg")
    //       .attr("viewBox", [-dy * padding / 2, x0 - dx, width, height])
    //       .attr("width", width)
    //       .attr("height", height)
    //       .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
    //       .attr("font-family", "sans-serif")
    //       .attr("font-size", 10);

    //   svg.append("g")
    //       .attr("fill", "none")
    //       .attr("stroke", stroke)
    //       .attr("stroke-opacity", strokeOpacity)
    //       .attr("stroke-linecap", strokeLinecap)
    //       .attr("stroke-linejoin", strokeLinejoin)
    //       .attr("stroke-width", strokeWidth)
    //     .selectAll("path")
    //       .data(root.links())
    //       .join("path")
    //         .attr("d", d3.link(curve)
    //             .x(d => d.y)
    //             .y(d => d.x));

    //   const node = svg.append("g")
    //     .selectAll("a")
    //     .data(root.descendants())
    //     .join("a")
    //       .attr("xlink:href", link == null ? null : d => link(d.data, d))
    //       .attr("target", link == null ? null : linkTarget)
    //       .attr("transform", d => `translate(${d.y},${d.x})`);

    //   node.append("circle")
    //       .attr("fill", d => d.children ? stroke : fill)
    //       .attr("r", r);

    //   if (title != null) node.append("title")
    //       .text(d => title(d.data, d));

    //   if (L) node.append("text")
    //       .attr("dy", "0.32em")
    //       .attr("x", d => d.children ? -6 : 6)
    //       .attr("text-anchor", d => d.children ? "end" : "start")
    //       .attr("paint-order", "stroke")
    //       .attr("stroke", halo)
    //       .attr("stroke-width", haloWidth)
    //       .text((d, i) => L[i]);

    //   return svg.node();
    // };

  </script>
</head>
<body class="container">
	<div style="display: flex; gap: 1rem;justify-content: flex-end;"><input type="number" value="25" id="spreadCountTimes"><button id="update_info">update</button></div>
	<div class="progress-9" style="display:none" id="progress"></div>
	<div id="animals"></div>
	<div id="d3_animals"></div>
  <script>
  // d3.select("#d3_animals").append("p").text("Hello World!");


  //   d3.select("#d3_animals")
  //   // d3.select("body")
  // .selectAll("p")
  // .data([4, 8, 15, 16, 23, 42])
  // .enter().append("p")
  //   .text(function(d) { return "I’m number " + d + "!"; });


  // var p = d3.select("#d3_animals")
    //   .selectAll("p")
    //   .data([4, 8, 15, 16, 23, 42])
    //     .text(function(d) { return d; });

    // // Enter…
    // p.enter().append("p")
    //     .text(function(d) { return d; });

    // // Exit…
    // p.exit().remove();


    // d3.select("#d3_animals").selectAll("circle").transition()
    //   .duration(750)
    //   .delay(function(d, i) { return i * 10; })
    //   .attr("r", function(d) { return Math.sqrt(d * scale); });

    // flare = FileAttachment("flare.json").json();

    // Tree = ƒ(sdds)

    // import { Tree } from "@d3/tree"

    var flare = {
      name: 'flare',
      children: [
        { name: 'analitycs', children: [{ name: 'analitycs', children: [{ name: 'analitycs', children: [] }] }, { name: 'analitycs', children: [] }] },
        { name: 'analitycs', children: [{ name: 'analitycs', children: [] }] },
        { name: 'analitycs', children: [] },
        { name: 'analitycs', children: [{ name: 'analitycs', children: [] },{ name: 'analitycs', children: [] },{ name: 'analitycs', children: [{ name: 'analitycs', children: [] },{ name: 'analitycs', children: [] },{ name: 'analitycs', children: [{ name: 'analitycs', children: [] }] }] }] },
      ]
    };

    chart = Tree(flare, {
      label: d => d.name,
      title: (d, n) => `${n.ancestors().reverse().map(d => d.data.name).join(".")}`, // hover text
      link: (d, n) => `https://github.com/prefuse/Flare/${n.children ? "tree" : "blob"}/master/flare/src/${n.ancestors().reverse().map(d => d.data.name).join("/")}${n.children ? "" : ".as"}`,
      width: 1152
    });
  </script>
</body>
<script>
const getParent = (beast, index) => beast[index] === null && beast[index] !== undefined
	? beast
	: getParent(beast[index], index);
const getNum = num => Math.round(Math.random(num));
const getRandNum = (max = 1, min = 0) => Math.round(Math.random() * (max - min) + min);

const makeStartBeasts = (array, count, time) => {
  for (var i = 0; i < count; i++) {
    var numberOfBeastList = getRandNum();
    array.live[numberOfBeastList].push({
      id: array.live[numberOfBeastList].length,
      // id0: null,
      // id1: null,
			0: null,
			1: null,
      time,
      gen: '000000'.replaceAll('0', () => getRandNum(9, 0)),
    });
  }

  // console.table(Object
  //     .keys(array.live[0][0])
  //     .map(keys => ({
  //       [keys]: array.live[0]
  //         .reduce((summ, el) =>
  //           ((summ < el[keys] && (summ += el[keys])), summ),
  //           ''
  //         )
  //     }))); // log start array

  return array;
};

const spread = (beasts, { maxLiveTime = 2, spreadCountTimes = 10, startCount = 20, maxChildrenCount = 2 }) => {
  var time = new Date().getFullYear();

  makeStartBeasts(beasts, startCount, time);

  for (var spreadCount = 0; spreadCount < spreadCountTimes; spreadCount++) {
    time++;

    if (beasts.live[0].length + beasts.live[1].length === 0) debugger;

    for (var i = 0; i < beasts.live[1].length; i++) {
      if (beasts.live[1][i] === undefined) continue;
      if ((beasts.live[1][i].time + getRandNum(maxLiveTime, 1)) < time ) {
        beasts.death[1].push(beasts.live[1][i]);
        beasts.live[1].splice(i, 1);
        i--;
      }
    }

    var beastsLive_1Copy = [...beasts.live[1]];

    for (var i = 0; i < beasts.live[0].length; i++) {
      if ((beasts.live[0][i].time + getRandNum(maxLiveTime, 1)) < time) {
        beasts.death[0].push(beasts.live[0][i]);
        beasts.live[0].splice(i, 1);
        i--;
        continue;
      }

      var parent = beasts.live[0][i];
      var partnerNum = getRandNum(beastsLive_1Copy.length - 1);
      var partnerBeast = beastsLive_1Copy[partnerNum];
      if (partnerBeast === undefined) continue;
      beastsLive_1Copy.splice(partnerNum, 1);

      // var countOfChildren = getNum(maxChildrenCount) + 1;

      for (var j = 0; j < maxChildrenCount; j++) {
        var numberOfBeastList = getRandNum();
        beasts.live[numberOfBeastList].push({
          id: beasts.live[numberOfBeastList].length,
          // id0: parent.id,
          // id1: partnerBeast.id,
					0: beasts.live[0][i],
          1: beastsLive_1Copy[partnerNum],
          time,
          gen: (numberOfBeastList === 0 ? parent : partnerBeast).gen.substring(0, 3) + (numberOfBeastList === 0 ? partnerBeast : parent).gen.substring(3, 6),
        });
      }
    }
  }

  return beasts;
}

const convertNumbers = num => new Intl.NumberFormat().format(num).replaceAll(',', '_');

const updateBeasts = (__, name, options = {}) => {
  const beasts = spread({ live: [[], []], death: [[], []] }, options = options || {});

  (() => {
		const liveStat = [...JSON.parse(localStorage.getItem('liveStat')) || [], convertNumbers(beasts.live[0].length + beasts.live[1].length)];
		localStorage.setItem('liveStat', JSON.stringify(liveStat));
		const deathStat = [...JSON.parse(localStorage.getItem('deathStat')) || [], convertNumbers(beasts.death[0].length + beasts.death[1].length)];
		localStorage.setItem('deathStat', JSON.stringify(deathStat));
		const l$dStat = [...JSON.parse(localStorage.getItem('l$dStat')) || [], convertNumbers(beasts.live[0].length - beasts.death[0].length + beasts.live[1].length - beasts.death[1].length)];
		localStorage.setItem('l$dStat', JSON.stringify(l$dStat));

    name = `${ name || 'Beasts' } <${ new Date().getMinutes() }:${ new Date().getSeconds() }> | <${ liveStat[liveStat.length - 1] }|${ deathStat[deathStat.length - 1] }|${ l$dStat[l$dStat.length - 1] }>`;
    console.group(name);
    console.table({ ...beasts /*, LiveStat: liveStat, DeathStat: deathStat, 'Live - Death stat': l$dStat */ });
    console.groupEnd(name);
  }) ();

  (() => {
    const divs = [document.createElement('div'), document.createElement('div')];
    // divs[0].style.backgroundColor = 'green';
    // divs[1].style.backgroundColor = 'red';
    divs[0].classList.add('container-a');
    divs[1].classList.add('container-a');

    const addOnPage = (arr, index) => arr.forEach(beast => {
      const div = document.createElement('div');
      div.style.backgroundColor = '#' + beast.gen;
      div.classList.add('beast');
      divs[index].append(div);
    });

    addOnPage(beasts.live[0].splice(0, beasts.live[0].length), 0);
    addOnPage(beasts.live[1].splice(0, beasts.live[1].length), 1);

    animals.innerHTML = '';
    animals.append(...divs);
  }) () // run ()

	return beasts;
};

const beasts = updateBeasts();
update_info.addEventListener('click', () => {
	animals.innerHTML = ''
	progress.style.display = '';
	setTimeout(() => updateBeasts('', '', { spreadCountTimes: spreadCountTimes.value }), 2000)
	// .then(() => progress.style.display = 'none');
	setTimeout(() => progress.style.display = 'none', 2000)

}, false);

// setInterval(() => updateBeasts(), 1000);

</script>
</html>
